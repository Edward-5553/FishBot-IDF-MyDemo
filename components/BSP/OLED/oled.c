/**
 * @brief OLED (SSD1306, I2C 0x3C) - IDF v4 旧代码的 v5 适配移植版
 *        - 采用项目现有 I2C 总线封装 myi2c.h（IDF v5 的 i2c_master_bus_* APIs）
 *        - 保留原始 API：oled_init / oled_clear / oled_setxy / oled_ascii / oled_ascii8 / oled_show_ascii_auto_line
 *        - 字体：沿用 6x8 ASCII（本文件中的 ascii[][]），8x16 ASCII 使用 oledfonts.h 的 asc2_1608
 */
#include "oled.h"
#include "myi2c.h"
#include "oledfonts.h"
#include "driver/i2c_master.h"
#include "esp_log.h"
#include <string.h>

#define FISHBOT_MODLUE "OLED"
#define OLED_MAX_LINES 7         /* 页 0..7，可显示 8 行；从 1 开始则最多 7 行 */
#define OLED_START_LINE 1

/* SSD1306 I2C 控制字节 */
#define OLED_CONTROL_CMD   0x00  /* 发送命令 */
#define OLED_CONTROL_DATA  0x40  /* 发送数据 */

#define OLED_I2C_TIMEOUT_MS 1000

static uint8_t last_line_ = 2;
static const char *TAG = "OLED_TMP";

/* I2C 设备句柄（在 myiic_init() 创建的 bus_handle 上添加设备）*/
static i2c_master_dev_handle_t s_oled_dev = NULL;

/* 6x8 ASCII（与原 v4 代码一致） */
static const uint8_t ascii[95][6] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // sp
    {0x00, 0x00, 0x00, 0x2f, 0x00, 0x00},  // !
    {0x00, 0x00, 0x07, 0x00, 0x07, 0x00},  // "
    {0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14},  // #
    {0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12},  // $
    {0x00, 0x62, 0x64, 0x08, 0x13, 0x23},  // %
    {0x00, 0x36, 0x49, 0x55, 0x22, 0x50},  // &
    {0x00, 0x00, 0x05, 0x03, 0x00, 0x00},  // '
    {0x00, 0x00, 0x1c, 0x22, 0x41, 0x00},  // (
    {0x00, 0x00, 0x41, 0x22, 0x1c, 0x00},  // )
    {0x00, 0x14, 0x08, 0x3E, 0x08, 0x14},  // *
    {0x00, 0x08, 0x08, 0x3E, 0x08, 0x08},  // +
    {0x00, 0x00, 0x00, 0xA0, 0x60, 0x00},  // ,
    {0x00, 0x08, 0x08, 0x08, 0x08, 0x08},  // -
    {0x00, 0x00, 0x60, 0x60, 0x00, 0x00},  // .
    {0x00, 0x20, 0x10, 0x08, 0x04, 0x02},  // /
    {0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E},  // 0
    {0x00, 0x00, 0x42, 0x7F, 0x40, 0x00},  // 1
    {0x00, 0x42, 0x61, 0x51, 0x49, 0x46},  // 2
    {0x00, 0x21, 0x41, 0x45, 0x4B, 0x31},  // 3
    {0x00, 0x18, 0x14, 0x12, 0x7F, 0x10},  // 4
    {0x00, 0x27, 0x45, 0x45, 0x45, 0x39},  // 5
    {0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30},  // 6
    {0x00, 0x01, 0x71, 0x09, 0x05, 0x03},  // 7
    {0x00, 0x36, 0x49, 0x49, 0x49, 0x36},  // 8
    {0x00, 0x06, 0x49, 0x49, 0x29, 0x1E},  // 9
    {0x00, 0x00, 0x36, 0x36, 0x00, 0x00},  // :
    {0x00, 0x00, 0x56, 0x36, 0x00, 0x00},  // ;
    {0x00, 0x08, 0x14, 0x22, 0x41, 0x00},  // <
    {0x00, 0x14, 0x14, 0x14, 0x14, 0x14},  // =
    {0x00, 0x00, 0x41, 0x22, 0x14, 0x08},  // >
    {0x00, 0x02, 0x01, 0x51, 0x09, 0x06},  // ?
    {0x00, 0x32, 0x49, 0x59, 0x51, 0x3E},  // @
    {0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C},  // A
    {0x00, 0x7F, 0x49, 0x49, 0x49, 0x36},  // B
    {0x00, 0x3E, 0x41, 0x41, 0x41, 0x22},  // C
    {0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C},  // D
    {0x00, 0x7F, 0x49, 0x49, 0x49, 0x41},  // E
    {0x00, 0x7F, 0x09, 0x09, 0x09, 0x01},  // F
    {0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A},  // G
    {0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F},  // H
    {0x00, 0x00, 0x41, 0x7F, 0x41, 0x00},  // I
    {0x00, 0x20, 0x40, 0x41, 0x3F, 0x01},  // J
    {0x00, 0x7F, 0x08, 0x14, 0x22, 0x41},  // K
    {0x00, 0x7F, 0x40, 0x40, 0x40, 0x40},  // L
    {0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F},  // M
    {0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F},  // N
    {0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E},  // O
    {0x00, 0x7F, 0x09, 0x09, 0x09, 0x06},  // P
    {0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E},  // Q
    {0x00, 0x7F, 0x09, 0x19, 0x29, 0x46},  // R
    {0x00, 0x46, 0x49, 0x49, 0x49, 0x31},  // S
    {0x00, 0x01, 0x01, 0x7F, 0x01, 0x01},  // T
    {0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F},  // U
    {0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F},  // V
    {0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F},  // W
    {0x00, 0x63, 0x14, 0x08, 0x14, 0x63},  // X
    {0x00, 0x07, 0x08, 0x70, 0x08, 0x07},  // Y
    {0x00, 0x61, 0x51, 0x49, 0x45, 0x43},  // Z
    {0x00, 0x00, 0x7F, 0x41, 0x41, 0x00},  // [
    {0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55},  // 55
    {0x00, 0x00, 0x41, 0x41, 0x7F, 0x00},  // ]
    {0x00, 0x04, 0x02, 0x01, 0x02, 0x04},  // ^
    {0x00, 0x40, 0x40, 0x40, 0x40, 0x40},  // _
    {0x00, 0x00, 0x01, 0x02, 0x04, 0x00},  // '
    {0x00, 0x20, 0x54, 0x54, 0x54, 0x78},  // a
    {0x00, 0x7F, 0x48, 0x44, 0x44, 0x38},  // b
    {0x00, 0x38, 0x44, 0x44, 0x44, 0x20},  // c
    {0x00, 0x38, 0x44, 0x44, 0x48, 0x7F},  // d
    {0x00, 0x38, 0x54, 0x54, 0x54, 0x18},  // e
    {0x00, 0x08, 0x7E, 0x09, 0x01, 0x02},  // f
    {0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C},  // g
    {0x00, 0x7F, 0x08, 0x04, 0x04, 0x78},  // h
    {0x00, 0x00, 0x44, 0x7D, 0x40, 0x00},  // i
    {0x00, 0x40, 0x80, 0x84, 0x7D, 0x00},  // j
    {0x00, 0x7F, 0x10, 0x28, 0x44, 0x00},  // k
    {0x00, 0x00, 0x41, 0x7F, 0x40, 0x00},  // l
    {0x00, 0x7C, 0x04, 0x18, 0x04, 0x78},  // m
    {0x00, 0x7C, 0x08, 0x04, 0x04, 0x78},  // n
    {0x00, 0x38, 0x44, 0x44, 0x44, 0x38},  // o
    {0x00, 0xFC, 0x24, 0x24, 0x24, 0x18},  // p
    {0x00, 0x18, 0x24, 0x24, 0x18, 0xFC},  // q
    {0x00, 0x7C, 0x08, 0x04, 0x04, 0x08},  // r
    {0x00, 0x48, 0x54, 0x54, 0x54, 0x20},  // s
    {0x00, 0x04, 0x3F, 0x44, 0x40, 0x20},  // t
    {0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C},  // u
    {0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C},  // v
    {0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C},  // w
    {0x00, 0x44, 0x28, 0x10, 0x28, 0x44},  // x
    {0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C},  // y
    {0x00, 0x44, 0x64, 0x54, 0x4C, 0x44},  // z
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x14},  // horiz lines
};

/* --- 基础 I2C 发送 --- */
static inline esp_err_t oled_tx_ctrl_data(uint8_t ctrl, const uint8_t *data, size_t len)
{
    if (!s_oled_dev) return ESP_ERR_INVALID_STATE;
    uint8_t buf[1 + 128];
    if (len > 128) return ESP_ERR_INVALID_ARG;
    buf[0] = ctrl;
    memcpy(&buf[1], data, len);
    return i2c_master_transmit(s_oled_dev, buf, 1 + len, OLED_I2C_TIMEOUT_MS);
}

static inline esp_err_t oled_send_cmd(uint8_t cmd)
{
    return oled_tx_ctrl_data(OLED_CONTROL_CMD, &cmd, 1);
}

static inline esp_err_t oled_send_cmds(const uint8_t *cmds, size_t n)
{
    for (size_t i = 0; i < n; ++i) {
        esp_err_t err = oled_send_cmd(cmds[i]);
        if (err != ESP_OK) return err;
    }
    return ESP_OK;
}

static inline esp_err_t oled_send_data(const uint8_t *data, size_t len)
{
    return oled_tx_ctrl_data(OLED_CONTROL_DATA, data, len);
}

static inline void oled_set_page_col(uint8_t page, uint8_t col)
{
    oled_send_cmd(0xB0 | (page & 0x07));
    oled_send_cmd(0x00 | (col & 0x0F));
    oled_send_cmd(0x10 | (col >> 4));
}

/* --- 对外 API --- */
bool oled_init(void)
{
    if (bus_handle == NULL) {
        ESP_LOGE(TAG, "I2C 总线未初始化，请先调用 myiic_init()");
        return false;
    }

    if (s_oled_dev) {
        i2c_master_bus_rm_device(s_oled_dev);
        s_oled_dev = NULL;
    }

    i2c_device_config_t dev_cfg = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = OLED_ADDR,
        .scl_speed_hz = IIC_SPEED_CLK,
    };
    esp_err_t err = i2c_master_bus_add_device(bus_handle, &dev_cfg, &s_oled_dev);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "添加 OLED 设备失败: %s", esp_err_to_name(err));
        return false;
    }

    /* 使用原始 v4 代码的初始化序列（逐条命令发送） */
    uint8_t cmd_data[] = {0xae, 0x20, 0x10, 0xb0, 0xc8, 0x00, 0x10,
                          0x40, 0x81, 0x7f, 0xa1, 0xa6, 0xa8, 0x3f,
                          0xa4, 0xd3, 0x00, 0xd5, 0xf0, 0xd9, 0x22,
                          0xda, 0x12, 0xdb, 0x20, 0x8d, 0x14, 0xaf};
    err = oled_send_cmds(cmd_data, sizeof(cmd_data));
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "OLED 初始化命令发送失败: %s", esp_err_to_name(err));
        return false;
    }

    oled_clear();
    oled_ascii8(0, 0, "        FISHBOT     ");
    oled_ascii8(0, 1, "Ver :V1.0.0.220820  ");
    ESP_LOGI(FISHBOT_MODLUE, "init success!");
    return true;
}

void oled_clear(void)
{
    uint8_t zeros[128];
    memset(zeros, 0x00, sizeof(zeros));
    for (int page = 0; page < 8; ++page) {
        oled_set_page_col(page, 0);
        oled_send_data(zeros, sizeof(zeros));
    }
}

void oled_setxy(uint8_t x, uint8_t y)
{
    if (y > 7) y = 7;
    if (x > 127) x = 127;
    oled_set_page_col(y, x);
}

bool oled_show_ascii_auto_line(char *str)
{
    if (!str) return false;
    size_t len = strlen(str);
    if (len > 21) {
        ESP_LOGW(FISHBOT_MODLUE, "len can't >21 char!");
        return false;
    }
    /* 清空本页并写入 */
    uint8_t blanks[128];
    memset(blanks, 0x00, sizeof(blanks));
    uint8_t page = last_line_;
    if (page > 7) page = OLED_START_LINE; /* 防越界 */
    oled_set_page_col(page, 0);
    oled_send_data(blanks, sizeof(blanks));
    oled_ascii8(0, page, str);

    last_line_ = (uint8_t)((page + 1) > OLED_MAX_LINES ? OLED_START_LINE : (page + 1));
    return true;
}

void oled_ascii8(uint8_t x, uint8_t y, char *str)
{
    if (!str) return;
    if (y > 7) y = 7;
    if (x > 127) x = 127;

    oled_set_page_col(y, x);
    int col = x;
    for (int i = 0; i < 21 && str[i] != 0; ++i) {
        uint8_t ch = (uint8_t)str[i];
        if (ch < 32 || ch > 126) ch = ' ';
        const uint8_t *glyph = ascii[ch - 32];
        if (col + 6 > 128) break; /* 当前行剩余不足 */
        oled_send_data(glyph, 6);
        col += 6;
    }
}

void oled_ascii(uint8_t x, uint8_t y, char *str)
{
    if (!str) return;
    /* 8x16 字符，每字宽 8 列，高跨两页（y 与 y+1） */
    uint8_t page_top = (y > 6) ? 6 : y;
    uint8_t col = (x > 127) ? 127 : x;

    for (int i = 0; i < 16 && str[i] != 0; ++i) {
        uint8_t ch = (uint8_t)str[i];
        if (ch < 32 || ch > 126) ch = ' ';
        const uint8_t *glyph = asc2_1608[ch - 32];
        if (col + 8 > 128) break; /* 当前行剩余不足 */

        /* 上半部分（8 字节） */
        oled_set_page_col(page_top, col);
        oled_send_data(glyph + 0, 8);

        /* 下半部分（8 字节） */
        oled_set_page_col(page_top + 1, col);
        oled_send_data(glyph + 8, 8);

        col += 8;
    }
}
